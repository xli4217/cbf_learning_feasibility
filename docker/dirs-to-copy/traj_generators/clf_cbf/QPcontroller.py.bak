#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from gurobipy import *
import math
import numpy as np


class QPcontroller:
    def __init__(self, config={}):
        self.k_cbf = 1 #CBF coefficient
        self.epsilon = 0.8 #Finite time CLF coefficient
        self.m = Model("CBF_CLF_QP")
        self.num_of_states = 3
        self.num_of_control_inputs = 3
        self.u1_upper_lim = 0.1 # From Create Autonomy
        self.u1_lower_lim = -0.1
        self.u2_upper_lim = 0.1
        self.u2_lower_lim = -0.1
        self.u3_upper_lim = 0.1
        self.u3_lower_lim = -0.1
        # self.desk_height = 0.59

        self.dt = 0.2
        self.goal = None

        # Control Variables
        self.u1 = self.m.addVar(lb=self.u1_lower_lim, ub=self.u1_upper_lim,vtype=GRB.CONTINUOUS, name="x1_input_acceleration")
        self.u2 = self.m.addVar(lb=self.u2_lower_lim, ub=self.u2_upper_lim,vtype=GRB.CONTINUOUS, name="x2_input_acceleration")
        self.u3 = self.m.addVar(lb=self.u3_lower_lim, ub=self.u3_upper_lim,vtype=GRB.CONTINUOUS, name="x3_input_acceleration")
        # Soft Constraint Variable for CLF
        self.delta = self.m.addVar(lb=-30, ub=30,vtype=GRB.CONTINUOUS, name="relaxation_CLF")


    def set_goal(self, goal):
        self.goal = goal

    def get_next_wp(self, action=None, curr_pose=None, curr_vel=None, obs_info={}):
        _, target_vel, target_pose = self.generate_control(curr_pose, obs_info)
        return None, target_vel, target_pose

    def generate_control(self,x_current, obs_info={}):
        
        num_of_obstacles = len(obs_info) #For later use when more obstacles are involved

        # Loop through sphereical obstacles and set constraints
        for i in range(0,num_of_obstacles):
            if obs_info[i]['name'] == 'table':
                table_height = obs_info[i]['position'][2]
                # Table Constraint
                h_table = (x_current[2]-table_height)**2
                self.m.addConstr(2*(x_current[2]-table_height)*self.u3 + self.k_cbf*h_table >= 0, "CBF_Constraint_for_table")
            else:
                pos = obs_info[i]['position']
                rad = obs_info[i]['radius']
                h = (x_current[0]-pos[0])**2 + (x_current[1]-pos[1])**2 + (x_current[2]-pos[2])**2 - rad**2
                self.m.addConstr(2*(x_current[0]-pos[0])*self.u1 + 2*(x_current[1]-pos[1])*self.u2 + 2*(x_current[2]-pos[2])*self.u3 + self.k_cbf*h >= 0, "CBF_Constraint_"+obs_info[i]['name'])


        # Initialize Cost Function
        self.cost_func = self.u1*self.u1+self.u2*self.u2+self.u3*self.u3 + self.delta*self.delta
        self.m.setObjective(self.cost_func,GRB.MINIMIZE)

        # CLF constraint
        V = 0.5*(x_current[0]-self.goal[0])**2 + 0.5*(x_current[1]-self.goal[1])**2 + 0.5*(x_current[2]-self.goal[2])**2

        partial_V_x1 = (x_current[0]-self.goal[0])
        partial_V_x2 = (x_current[1]-self.goal[1])
        partial_V_x3 = (x_current[2]-self.goal[2])


        self.m.addConstr(partial_V_x1*self.u1 + partial_V_x2*self.u2 + partial_V_x3*self.u3 + self.epsilon +self.delta <= -20, "Relaxed_CLF_constraint")

        #self.m.addConstr(partial_V_x1*self.u1 + partial_V_x2*self.u2 + partial_V_x3*self.u3 + self.epsilon * V - self.delta  <= 0, "Relaxed_CLF_constraint")


        #Stop optimizer from publsihing results to console - remove if desired
        self.m.Params.LogToConsole = 0

        #Solve the optimization problem
        self.m.optimize()
        self.solution = self.m.getVars()

        # get final decision variables
        self.control_u1 = self.solution[0].x
        self.control_u2 = self.solution[1].x
        self.control_u3 = self.solution[2].x

        # For debuging only, save model to view constraints etc.
        #self.m.write("qp_model.lp")

        target_vel = np.array([self.control_u1, self.control_u2, self.control_u3])

        target_pose = x_current + target_vel * self.dt


        # return None, None, target_pose
        return None, target_vel, target_pose
